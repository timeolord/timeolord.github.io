<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Allan Wei's Blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
        </script>
        <header>
            <div class="logo">
                <img src="../images/wei-logo.svg" style="width:50%; max-width:80px; display: block; margin-left: auto; margin-right: auto;" />
                <a href="../">The Wei Zone</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blogs</a>
            </nav>
        </header>

        <main role="main">
            <h1>Coroutines with the Continuation and State Monad</h1>
            
<article>
    <section class="header">
        <p>Posted on August 16, 2023</p><br>
        
    </section>
    <section>
        <p>Coroutines are a powerful feature that can help you create responsive games. Coroutines are functions that can pause and resume their execution at any point, without blocking the main thread of the game. This allows you to perform tasks that require waiting, delays, or multiple steps, without affecting the responsiveness of your game. There are a perfect abstraction for modeling events over time, such as animations, physics, and AI.</p>
<p>For example, imagine you want to create a simple animation where a character moves from one point to another, while changing its color and size. You could write a coroutine that updates the character’s position, color, and size every frame, and pauses until the next frame using the yield statement, without worrying about an explicit time parameter.</p>
<p>Coroutines are a common feature in many programming languages, such as Lua, Python, and C#. However, they are not a native feature of Haskell. In this article, we will explore how to implement coroutines in Haskell using continuations and monads. We will also see how to use coroutines to create a simple game.</p>
<h2 id="what-is-a-continuation">What is a continuation?</h2>
<p>A continuation is a way of representing the state of a computation at any point in time. Like a snapshot of what the program is doing and what it needs to do next. A continuation can be used to resume the computation from where it left off, or to transfer the control to a different part of the program. A continuation can also be passed as an argument to another function, which can then decide how to continue the computation. This is called continuation-passing style, and it is a common technique in functional programming languages.</p>
<p>One way to understand continuations is to imagine that every function has an extra parameter that represents what the function should do after it finishes its work. This parameter is called the continuation, and it is usually a function that takes the result of the original function as its input. For example, suppose we have a function</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>We can rewrite it in continuation-passing style as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">idCps ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>idCps x k <span class="ot">=</span> k x</span></code></pre></div>
<p>where <code>k</code> is the continuation. The function <code>id_cps</code> calls <code>k</code> with <code>x</code>. Since continuations allow you to transfer the control to a different part of the program, we can use them to implement control flow constructs such as <code>if</code>. For example, we can implement <code>if</code> as</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifCps ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>ifCps <span class="dt">True</span> t f a <span class="ot">=</span> t a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ifCps <span class="dt">False</span> t f a <span class="ot">=</span> f a</span></code></pre></div>
<p>where <code>t</code> is the continuation that will be called if the condition is true, and <code>f</code> is the continuation that will be called if the condition is false. We can use <code>ifCps</code> to implement a function that returns the absolute value of a number:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absCps ::</span> (<span class="dt">Num</span> r, <span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>absCps x k <span class="ot">=</span> ifCps (x <span class="op">&gt;=</span> <span class="dv">0</span>) k (\x <span class="ot">-&gt;</span> k (<span class="op">-</span>x)) x</span></code></pre></div>
<p>which we can use as</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> absCps (<span class="op">-</span><span class="dv">5</span>) <span class="fu">id</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<h2 id="monadic-continuations">Monadic continuations</h2>
<p>Continuations are a powerful abstraction, but they are not very convenient to use. Continuations are functions that take a single argument, and return a value. This means that if we want to use continuations to implement a coroutine, we would have to explicitly pass the continuation to each function.</p>
<p>Instead we can use the monad abstraction to simplify this process.</p>
<h2 id="what-is-monad">What is Monad?</h2>
<p>A monad is a concept from category theory. A category is a collection of objects and arrows, called morphisms, between them, that satisfy some basic rules. For example, the category of sets has sets as objects and functions as arrows.</p>
<p>A functor is a way of mapping one category to another, preserving the structure of the objects and arrows. For example, the power set functor maps any set to its power set (the set of all subsets), and any function to the function that takes the image of each subset.</p>
<p>An endofunctor is a functor that maps a category to itself. For example, the power set functor is an endofunctor on the category of sets.</p>
<p>A monad is a special kind of endofunctor, that comes with two additional operations: unit and join. The unit operation takes any object in the category and returns an object in the image of the endofunctor. The join operation takes any object in the image of the endofunctor applied twice, and returns an object in the image of the endofunctor applied once. These operations have to satisfy some coherence conditions, similar to the ones for monoids (which are structures with a binary operation and an identity element).</p>
<p>One way to think about a monad is that it adds some extra layer of structure or context to the objects and arrows in the category. For example, the power set monad adds the structure of subsets and inclusion relations. The unit operation wraps an object into a singleton subset, and the join operation flattens a set of subsets into a single subset.</p>
<p>This abstraction is a perfect abstraction for our coroutines, since the continuation is the context that we must pass around to every function that uses the coroutine.</p>
<h2 id="monadic-continuations-1">Monadic continuations</h2>
<p>We can use the monad abstraction to simplify the implementation of coroutines. We can define a monad that represents a continuation as</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f m <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont m (c <span class="op">.</span> f)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Cont</span> (<span class="op">$</span> a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont m <span class="op">$</span> \a <span class="ot">-&gt;</span> runCont (k a) c</span></code></pre></div>
<p>where <code>r</code> is the type of the result, and <code>a</code> is the type of the value. The <code>runCont</code> function takes a continuation as an argument, and returns the result of the continuation. We can use this monad to implement our previous functions <code>idCps</code>, <code>ifCps</code>, and <code>absCps</code> as</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">idCps ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>idCps x <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k x</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">ifCps ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ifCps <span class="dt">True</span> t f <span class="ot">=</span> t</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>ifCps <span class="dt">False</span> t f <span class="ot">=</span> f</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ot">absCps ::</span> (<span class="dt">Num</span> r, <span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>absCps x <span class="ot">=</span> ifCps (x <span class="op">&gt;=</span> <span class="dv">0</span>) (idCps x) (idCps (<span class="op">-</span>x))</span></code></pre></div>
<p>which gives us the same results as before:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont (absCps (<span class="op">-</span><span class="dv">5</span>)) <span class="fu">id</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<p>While the Cont Monad gives us a good basis for implementing coroutines, we also need to track the state as well, otherwise, we would not be able to resume the coroutine from where it left off.</p>
<h2 id="monadic-state">Monadic State</h2>
<p>We can use the State monad to track the state of the coroutine. The State monad is a monad that takes a state as an argument, and returns a value and a new state. We can define the State monad as</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f m <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s') <span class="ot">=</span> runState m s <span class="kw">in</span> (f a, s')</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s') <span class="ot">=</span> runState m s <span class="kw">in</span> runState (k a) s'</span></code></pre></div>
<p>The state monad are functions of the type <code>s -&gt; (a, s)</code>, which take a state as an argument, and return a value and a new state. We can use this monad to implement a function that increments a counter as</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inc ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>inc <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (s, s <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>which we can use as</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runState inc <span class="dv">0</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">1</span>) <span class="co">-- 0 is the value, and 1 is the new state</span></span></code></pre></div>
<p>Now we are familiar with the two monads that we need to implement coroutines. We have to figure out how to combine them together. We can use the monad transformer to combine many monad transformers together.</p>
<h2 id="monad-transformers">Monad Transformers</h2>
<p>A monad transformer is a monad that takes another monad as an argument, and returns a new monad. To use monad transformers we have to redefine our previous monads to take an additional <code>m</code> argument, which stands for an arbitrary monad. By convention the transformer version of a monad is prepended with a capital T. For example, the transformer version of the State monad is called <code>StateT</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="ot">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f m <span class="ot">=</span> <span class="dt">StateT</span> (<span class="fu">fmap</span> (\(a, s') <span class="ot">-&gt;</span> (f a, s')) <span class="op">.</span> runStateT m)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">pure</span> (a, s)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        (a, s') <span class="ot">&lt;-</span> runStateT m s</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        runStateT (k a) s'</span></code></pre></div>
<p>As you can see the only difference between the State monad and the StateT monad is that the StateT monad takes an additional <code>m</code> argument, and uses the <code>m</code> monad to combine the results of the two monads together. With the monad transformer we can define the base monad by using the identity monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f m <span class="ot">=</span> <span class="dt">Identity</span> (f (runIdentity m))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Identity</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> k (runIdentity m)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span> a</span></code></pre></div>
<p>By the way all of these monad transformers are implemented in the <a href="https://hackage.haskell.org/package/mtl">mtl package</a>, so you don’t have to implement them yourself. We are just implementing them here to explain the process from scratch and to understand how they work. For the rest of this post, I’ll be using the <code>mtl</code> package for the monad transformers, since it comes with some useful typeclasses that reduce boilerplate.</p>
<p>We can do the same for the Cont monad, but I’ll leave that as an exercise for the reader.</p>
<h2 id="coroutine-monad">Coroutine Monad</h2>
<p>Now how do we actually go about using these monad transformers to implement coroutines? Well importantly coroutines can stop and start, so we need to be able to store the state of the coroutine. We can do this by storing the continuation in a list. Let’s implement a data type that can do this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Coroutine</span> r m a <span class="ot">=</span> <span class="dt">Coroutine</span> {<span class="ot"> runCoroutine' ::</span> <span class="dt">ContT</span> r (<span class="dt">StateT</span> [<span class="dt">Coroutine</span> r m ()] m) a }</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Coroutine</span> c) <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">$</span> <span class="fu">fmap</span> f c</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">.</span> <span class="fu">pure</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Coroutine</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">Coroutine</span> a) <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">$</span> f <span class="op">&lt;*&gt;</span> a</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Coroutine</span> a) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">$</span> a <span class="op">&gt;&gt;=</span> runCoroutine' <span class="op">.</span> f</span></code></pre></div>
<p>By the way this wonderful coroutine type was borrowed from <a href="https://iamemhn.link/rom/continuations/">this great tutorial</a>. The continuation monad has a runCont of type <code>(a -&gt; (StateT [Coroutine r m ()] m) r) -&gt; (StateT [Coroutine r m ()] m) r</code>. For reasons you’ll see later the types of <code>r</code> and <code>a</code> are equivalent, and <code>a == ()</code>, so in reality the type becomes <code>(() -&gt; (StateT [Coroutine () m ()] m) ()) -&gt; (StateT [Coroutine () m ()] m) ()</code>, with only the monad <code>m</code> as a free type. With so many <code>()</code> you can probably smell that we are going to be writing our coroutines in a imperative style. Other than this datatype, this is all pretty standard boilerplate for monads, however, <code>mtl</code> introduces a few other typeclasses that are nice to have and makes your code more concise, so let’s implement those as well</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadCont</span> (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    callCC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m b) <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m a) <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    callCC f <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">$</span> callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> runCoroutine' (f (<span class="dt">Coroutine</span> <span class="op">.</span> k))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    liftIO ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m a</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">.</span> liftIO</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Coroutine</span> r) <span class="kw">where</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m a</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    lift <span class="ot">=</span> <span class="dt">Coroutine</span> <span class="op">.</span> lift <span class="op">.</span> lift</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    get ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m s</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    get <span class="ot">=</span> lift get</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="ot">    put ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    put <span class="ot">=</span> lift <span class="op">.</span> put</span></code></pre></div>
<p><code>MonadCont</code> provides a function named <code>callCC</code> which I’ll explain in detail later. <code>MonadIO</code> allows us to lift IO actions into our coroutine. <code>MonadTrans</code> allows us to lift monadic actions into our coroutine. <code>MonadState</code> allows us to use the state monad inside our coroutine. I added the function signatures to make it clear what each function does. Importantly the implementation of MonadState requires the <code>UndecidableInstances</code> extension. This is because the <code>MonadState</code> typeclass has a functional dependency <code>m -&gt; s</code>, which means that the compiler can infer the type of the state from the type of the monad. However, since we are using a monad transformer, the compiler cannot infer the type of the state from the type of the monad, so we have to explicitly tell the compiler that it is safe to use this instance. In general most <code>MultiParamTypeClasses</code> with functional dependencies need <code>UndecidableInstances</code>. In theory this could be resolved using type families, but that is beyond the scope of this article.</p>
<h2 id="call-me-the-current-continuation-maybe">Call Me (The Current Continuation) Maybe</h2>
<p>Before I continue into the implementation I have to talk about <code>callCC</code>. <code>callCC</code> is a powerful and somewhat <a href="https://okmij.org/ftp/continuations/against-callcc.html">controversial</a> abstraction. It stands for call with current continuation, but what does that mean? Well let’s look at an example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">succCont ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>succCont n <span class="ot">=</span> <span class="fu">return</span> (<span class="fu">succ</span> n)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">succCallCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">Int</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>succCallCC n <span class="ot">=</span> callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> k (<span class="fu">succ</span> n)</span></code></pre></div>
<p>So <code>callCC</code> is a function that takes another function as input. The <code>k</code> that the lambda function takes as an argument is another function. The <code>k</code> function has the effect of <code>return</code> in an an imperative language, as in no mater what is after <code>k</code>, once you call <code>k</code> the entire <code>callCC</code> block returns with the value passed into <code>k</code>. To break down the types to see if we can understand <code>callCC</code> better. <code>k</code> has the type <code>Int -&gt; Cont r Int</code>. Notice that the signature of <code>k</code> is the same as <code>succCallCC</code>, if we use our intuition that <code>k</code> acts as an early return then this makes sense, since after we call <code>k</code> the entire function must return, and so the argument (in this case <code>Int</code>) types must be the same. The type of <code>callCC</code> is a bit more weird, it has the type <code>((a -&gt; Cont r b) -&gt; Cont r a) -&gt; Cont r a</code>, so it takes a function which has argument <code>(a -&gt; Cont r b)</code> which is our <code>k</code>, and returns a <code>Cont r a</code>, and then <code>callCC</code> returns a <code>Cont r a</code>. But the best thing about this function is that <code>k</code> is just an ordinary function, we can do whatever we want with it including storing it in data structures to use later. This is exactly what we are going to do with our coroutine. We are going to store the continuations in a list, and then we can use it later to resume the coroutine. Just to solidify the idea of <code>callCC</code> I’ll show you one more example, where we can use <code>callCC</code> to implement perform a jump.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">jump ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">String</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>jump n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    msg <span class="ot">&lt;-</span> callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        condition n k</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> n' <span class="ot">=</span> n <span class="op">+</span> <span class="dv">12</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> n'</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> msg</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="ot">condition ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r ()) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r ()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>condition <span class="dv">0</span> k <span class="ot">=</span> k <span class="st">&quot;jumped on zero&quot;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>condition <span class="dv">2</span> k <span class="ot">=</span> k <span class="st">&quot;jumped on two&quot;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>condition _ k <span class="ot">=</span> <span class="fu">return</span> ()</span></code></pre></div>
<p>In this case we are using <code>callCC</code> to implement a jump. If <code>n</code> is equal to <code>0</code> or 2 then the evaluation of the entire <code>callCC</code> block will return, and notice that we passed <code>k</code> into another function, so in essence this function will jump to the <code>callCC</code> block with the value applied to <code>k</code>, otherwise it will return <code>show n'</code>. Importantly, the rest of the code after the <code>callCC</code> block will not be evaluated. So while the imperative return idea helps to understand <code>callCC</code>, in fact it is more powerful than <code>return</code> in a language like C, since it can jump to any point in the code, not just the end of the function.</p>
<h2 id="coroutine-implementation">Coroutine Implementation</h2>
<p>With some understanding of <code>callCC</code>, we can now implement our coroutines. First, let’s implement the getters and setters for the continuation queue:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getContinuations ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m [<span class="dt">Coroutine</span> r m ()]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>getContinuations <span class="ot">=</span> <span class="dt">Coroutine</span> get</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putContinuations ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">Coroutine</span> r m ()] <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>putContinuations <span class="ot">=</span> <span class="dt">Coroutine</span> put</span></code></pre></div>
<p>Observant readers might notice that these implementations are almost identical to the <code>get</code> and <code>put</code> we implemented for the instance of <code>MonadState</code>. However, these functions are different, because <code>get</code> and <code>put</code> access the state of the monad <code>m</code> inside our coroutine transformer</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">Coroutine</span> r m) <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    get ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m s</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    get <span class="ot">=</span> lift get</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    put ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    put <span class="ot">=</span> lift <span class="op">.</span> put</span></code></pre></div>
<p>while <code>getContinuations</code> and <code>putContinuations</code> access the state internal coroutine list, which is always <code>[Coroutine r m ()]</code>.</p>
<p>Now we can implement a queue and scheduler for our coroutines:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queue ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m () <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>queue p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    ccs <span class="ot">&lt;-</span> getContinuations</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    putContinuations <span class="op">$</span> ccs <span class="op">++</span> [p]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ot">schedule ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>schedule <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    ready <span class="ot">&lt;-</span> getContinuations</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ready <span class="kw">of</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        []     <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        (p<span class="op">:</span>ps) <span class="ot">-&gt;</span> <span class="kw">do</span> </span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>            putContinuations ps</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>            p</span></code></pre></div>
<p>The <code>queue</code> function takes a coroutine and adds it to the end of the queue. The <code>schedule</code> function takes the first coroutine from the queue, and runs it. If the queue is empty, then it returns. Now we can implement the control primitives <code>fork</code> and <code>yield</code></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>yield <span class="ot">=</span> callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    queue (k ())</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    schedule</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fork ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m () <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>fork p <span class="ot">=</span> callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>     queue (k ())</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>     p</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>     schedule</span></code></pre></div>
<p>The difference between <code>yield</code> and <code>fork</code> is that <code>yield</code> adds the current continuation to the queue, and then schedules the next coroutine, while <code>fork</code> adds the current continuation to the queue, runs the coroutine <code>p</code>, and then schedules the next coroutine. To finish up we just need a way to run our coroutines:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">finished ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m ()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>finished <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  remaining <span class="ot">&lt;-</span> Prelude.null <span class="op">&lt;$&gt;</span> getContinuations</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    unless remaining Main.yield</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    finished</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="ot">runCoroutine ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Coroutine</span> r m r <span class="ot">-&gt;</span> m r</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>runCoroutine coroutine <span class="ot">=</span> evalStateT (runContT (runCoroutine' <span class="op">$</span> coroutine <span class="op">&lt;*</span> finished) <span class="fu">return</span>) []</span></code></pre></div>
<p>Most of the runCoroutine function is just running each monad within the transformer. In essence it runs the coroutine, which has an addition of <code>finished</code>, which checks if the queue is empty, and if it is not empty, then it yields to the next coroutine. This is important, because otherwise the coroutine would end after the first <code>yield</code>. Then we run the continuation, with return, and finally we run the state monad, which is just the empty list.</p>
<p>Now let’s come back into the real world and see how we can use coroutines to implement a simple event over time. Let’s say you are making worm game, and you want to implement an idle animation for the worm, where the length of the worm changes over time. We can implement this as a coroutine. First, let’s define a plausible game environment:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GameStateT</span> m <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">GameState</span> m</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Length</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GameState</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">Length</span></span></code></pre></div>
<p>Now we can write the idle animation for the worm using coroutines like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">wormState ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> () (<span class="dt">GameStateT</span> m) ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>wormState name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    modify (insert name <span class="dv">4</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">12</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        Main.yield</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        modify (adjustWithKey (<span class="fu">const</span> <span class="fu">succ</span>) name)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    replicateM_ <span class="dv">12</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        Main.yield</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        modify (adjustWithKey (<span class="fu">const</span> <span class="fu">pred</span>) name)</span></code></pre></div>
<p>The <code>modify</code> function is from the <code>mtl</code> package, and it is a convenience function that takes a function that modifies the state, and applies it to the state. The <code>adjustWithKey</code> function is from the <code>containers</code> package, and it is a convenience function that takes a function that modifies the value of a key, and applies it to the value of the key. In terms of the animation, this worm starts at an initial size of 4, over 12 frames it increases its size each frame, then over the next 12 frames it decreases its size each frame.</p>
<p>We can implement a simple render coroutine that displays our worm:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">render ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Coroutine</span> () (<span class="dt">GameStateT</span> m) ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>render name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    l <span class="ot">&lt;-</span> get</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> worm <span class="ot">=</span> <span class="fu">concat</span> <span class="op">$</span> <span class="fu">maybe</span> [] (\x <span class="ot">-&gt;</span> <span class="fu">replicate</span> (x <span class="op">+</span> <span class="dv">1</span>) <span class="st">&quot;#&quot;</span>) (Data.Map.Strict.lookup name l)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">putStr</span> <span class="st">&quot;\ESC[2J&quot;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">putStrLn</span> worm</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> threadDelay <span class="dv">50000</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    Main.yield</span></code></pre></div>
<p><code>threadDelay</code> is there to limit the frame rate of the animation, otherwise it’ll be too fast, for a real game you would definitely use a more sophisticated method of synchronization. The <code>putStr "\ESC[2J"</code> is there to clear the screen before rendering the worm. The <code>liftIO</code> function is from the <code>mtl</code> package, and it is a convenience function that lifts an IO action into the monad.</p>
<p>Now we can combine these two coroutines together to create a simple game loop:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gameCoroutine ::</span> <span class="dt">Coroutine</span> () (<span class="dt">GameStateT</span> <span class="dt">IO</span>) ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>gameCoroutine <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> wormName <span class="ot">=</span> <span class="st">&quot;Níðhöggr&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    fork <span class="op">.</span> forever <span class="op">.</span> wormState <span class="op">$</span> wormName</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    fork <span class="op">.</span> forever <span class="op">.</span> render <span class="op">$</span> wormName</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> execStateT (runCoroutine gameCoroutine) Data.Map.Strict.empty</span></code></pre></div>
<p>Running this we get something like this:</p>
<p><img src="../images/coroutine-worm.gif" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this article we explored how to implement coroutines in Haskell using continuations and monads. We also saw how to use coroutines to create a simple animation. Coroutines are a powerful abstraction that can help you create responsive games. Coroutines allow you to perform tasks that require waiting, delays, or multiple steps, without affecting the responsiveness of your game. There are a perfect abstraction for modeling events over time, such as animations, physics, and AI.</p>
<p>However, continuations aren’t the only method of implementing coroutines. This <a href="https://hackage.haskell.org/package/monad-coroutine-0.9.2/docs/Control-Monad-Coroutine.html">implementation</a> uses trampolining to implement coroutine and also warps values in an functor. Their method allows for coroutines to take parameters upon resumption and yield values directly, which our coroutine implementation is unable to do. However, we can use state monads to overcome this issue, but our design is definitely less ergonomic. Additionally the use of continuations and <code>callCC</code> in Haskell is somewhat controversial since laziness allows for techniques that otherwise require continuations in other languages. Continuations can also severely reduce code readability, and can be difficult to debug.</p>
<p>Overall, when considering powerful abstractions like continuations, the most important question to ask is do we actually need all that power?</p>
<p>I hope you enjoyed reading and learned something new from this article. The full source code can be found <a href="https://github.com/timeolord/coroutines-with-continuations">here</a> at my Github.</p>
    </section>
</article>
        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
