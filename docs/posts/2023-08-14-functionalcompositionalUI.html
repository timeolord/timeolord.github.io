<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Allan Wei's Blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
        </script>
        <header>
            <div class="logo">
                <img src="../images/wei-logo.svg" style="width:50%; max-width:80px; display: block; margin-left: auto; margin-right: auto;" />
                <a href="../">The Wei Zone</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blogs</a>
            </nav>
        </header>

        <main role="main">
            <h1>Entity Component System with Lenses</h1>
            
<article>
    <section class="header">
        <p>Posted on August 14, 2023</p><br>
        
    </section>
    <section>
        <p>Entity Component Systems (ECS) are the new hot thing in game development. Both Unity and Unreal have adopted them, with major improvements compared to the classic object orientated style. I’ve been using them for a while now, and I’ve found them to be a great way to organize game code. In this post I wanted to implement my own ECS in Haskell, while using lenses to make it very concise. I’ll also show how to use the ECS to implement a simple physics simulator.</p>
<h2 id="what-is-ecs">What is ECS?</h2>
<p>ECS is a design pattern for developing games and simulations that focuses on the composition of entities, components, and systems. Here is a brief overview of each concept:</p>
<ul>
<li><p>Entities are the basic units of the game world. They are usually represented by an ID or a reference, and they have no logic or data by themselves.</p></li>
<li><p>Components are data containers that store the attributes and state of an entity. They are usually represented by structs or classes, and they can be attached to or detached from entities at runtime. Examples of components are position, velocity, health, sprite, etc.</p></li>
<li><p>Systems are functions or objects that implement the logic and behavior of the game. They operate on entities that have specific components, and they can read or write the data of those components. Examples of systems are movement, collision, rendering, input, etc.
The main advantages of ECS are:</p></li>
<li><p>Modularity: Entities can be easily created and modified by adding or removing components, without affecting the existing code or data structures.</p></li>
<li><p>Performance: Systems can process entities in batches, taking advantage of cache locality and parallelism. Components can also be stored in memory-efficient ways, such as arrays or pools.</p></li>
<li><p>Maintainability: Systems are decoupled from each other and from the data they operate on, making the code easier to understand and debug.</p></li>
</ul>
<p>In our implementation I will focus on the modularity aspect, and I will show how to use lenses to make the code very concise and easy to use. Since this is in Haskell, I won’t worry about performance for our implementation, and often focusing on performance in Haskell can make the code quite ugly.</p>
<h2 id="what-are-lenses">What are Lenses?</h2>
<p>Lenses have been around for a while, but they have recently become popular in the Haskell community (for a <a href="https://github.com/ekmett/lens/wiki/History-of-Lenses">brief history</a>). There are two primary libraries for lenses, <code>lens</code> and <code>optics</code>. We will be using <code>lens</code> for this post. The basic idea of a lens is that it is a collection of a getter and a setter. So we can imagine something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lens</span> a b <span class="ot">=</span> <span class="dt">Lens</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    get ::</span> a <span class="ot">-&gt;</span> b,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    set ::</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These operate on <code>b</code> and either return an <code>a</code> in that <code>b</code> or returns a new <code>b</code> with the given <code>a</code> respectively. If we have a record we can create a lens for each field of the record:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span> {<span class="ot"> _bar ::</span> <span class="dt">Int</span>,<span class="ot"> _baz ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Foo</span></span></code></pre></div>
<p>This uses the <code>lens</code> library to automatically generate lenses for each field of the record using template Haskell. The generated lenses require the fields to be prepended with an underscore. We can use these lenses to get and set the fields of the record:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">Foo</span> <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>view bar foo <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>view baz foo <span class="op">==</span> <span class="dv">1</span></span></code></pre></div>
<p><code>view</code> is the first of many functions you will be using to work with lenses. <code>view</code> simply returns the value of the lens, like <code>get</code>. The <code>bar</code> and <code>baz</code> lenses are generated by <code>makeLenses</code>, and they are used to get the value of the <code>bar</code> and <code>baz</code> fields respectively. We can also use lenses to set the fields of the record:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>set bar <span class="dv">3</span> foo <span class="op">==</span> <span class="dt">Foo</span> <span class="dv">3</span> <span class="dv">2</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>set baz <span class="dv">3</span> foo <span class="op">==</span> <span class="dt">Foo</span> <span class="dv">1</span> <span class="dv">3</span></span></code></pre></div>
<p><code>set</code> does exactly what you would expect given a lens. In fact <code>set</code> is actually a specialized version of <code>over</code>, which is a more general function that takes a function and applies it to the value of the lens:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>over bar (<span class="op">+</span><span class="dv">1</span>) foo <span class="op">==</span> <span class="dt">Foo</span> <span class="dv">2</span> <span class="dv">2</span></span></code></pre></div>
<p>These functions also all have operator forms:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">^.</span>) <span class="ot">=</span> view</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.~</span>) <span class="ot">=</span> set</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">%~</span>) <span class="ot">=</span> over</span></code></pre></div>
<p>The first remarkable thing about lenses is that they can compose seamlessly. For example, if we have a record within a record, we can compose the lenses to get the value of the inner record:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span> {<span class="ot"> _bar ::</span> <span class="dt">Bar</span> }</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bar</span> <span class="ot">=</span> <span class="dt">Bar</span> {<span class="ot"> _baz ::</span> <span class="dt">Int</span> }</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Foo</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Bar</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">Foo</span> <span class="op">$</span> <span class="dt">Bar</span> <span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>view (bar <span class="op">.</span> baz) foo <span class="op">==</span> <span class="dv">1</span></span></code></pre></div>
<p>Notice that the composition operator is just standard function composition, and also that the composition order is reversed. This gives us a syntax to access nested records similarly to imperative languages. A common idiom to access a deeply nested value is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>foo<span class="op">^.</span>bar<span class="op">.</span>baz <span class="op">==</span> <span class="dv">1</span></span></code></pre></div>
<p>This uses the operator version of view and looks remarkably similar to imperative languages. While we can imagine the lens type as a record in reality it is a bit more complicated. The actual lens type is:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span></code></pre></div>
<p>This is where the power of lens truly shine. The type of lens is complicated because it is highly generic. There are also many more representations of a lens, but this specific representation is called a van Laarhoven lens. The <code>s</code> and <code>t</code> type parameters are the source and target types respectively. The <code>a</code> and <code>b</code> type parameters are the focus and result types respectively. The <code>f</code> type parameter is a functor, and it is used to generalize the lens. The <code>forall</code> quantifier is used to make the lens polymorphic over any functor. A simplified version of the lens type is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens'</span> s a <span class="ot">=</span> <span class="dt">Lens</span> s s a a</span></code></pre></div>
<p>Another formalization of <code>lens</code> are as a Store comonad (I covered the Store comonad <a href="https://allanwei.com/posts/2023-08-17-comonadic2048.html">previously</a>):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> a b <span class="ot">=</span> <span class="dt">Store</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> pos  ::</span> a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> peek ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>While lens are important, in fact it is only one of many in a larger field called optics. Optics are a generalization, and they include many other types. We will briefly describe the key characteristics of the other types of optics.</p>
<ol type="1">
<li>Getter is read-only view of a exactly one value.</li>
<li>Setter is a write-only view of a exactly one value.</li>
<li>Lens is a read-write view of exactly one value.</li>
<li>Traversal is a read-write view of zero or more values.</li>
<li>Fold is a read-only view of zero or more values.</li>
<li>Iso is short for Isomorphism and is a lens that can be used in both directions.</li>
<li>Prisms are used to extract one value out of a sum type.</li>
</ol>
<p>There also exists subtyping between optics, for example a lens is also a getter, and a traversal is also a fold. You can find a full subtyping chart <a href="https://i.imgur.com/ALlbPRa.png">here</a>. The most important optics for our use case are traversals and lenses. If you have a good intuition with <code>Traversable</code> then traversals should seem familiar, as they are just a generalized version of <code>Traversable</code>.</p>
<h2 id="ecs-implementation">ECS Implementation</h2>
<p>Now that we have a basic understanding of ECS and lenses, let’s implement our own ECS in Haskell. We will start by defining the basic types and functions that we will need.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">System</span> m <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">ECSState</span> m</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ECSState</span> <span class="ot">=</span> <span class="dt">ECSState</span> {</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    _currentEntityID ::</span> <span class="dt">Entity</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    _componentsList ::</span> <span class="dt">Map</span> <span class="dt">Entity</span> <span class="dt">Components</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Default</span> <span class="dt">ECSState</span> <span class="kw">where</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    def <span class="ot">=</span> <span class="dt">ECSState</span> def def</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Entity</span> <span class="ot">=</span> <span class="dt">ID</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Entity</span> <span class="kw">where</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    (<span class="op">+</span>) (<span class="dt">ID</span> x) (<span class="dt">ID</span> y) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> x <span class="op">+</span> y</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    (<span class="op">*</span>) (<span class="dt">ID</span> x) (<span class="dt">ID</span> y) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> x <span class="op">*</span> y</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    (<span class="op">-</span>) (<span class="dt">ID</span> x) (<span class="dt">ID</span> y) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> x <span class="op">-</span> y</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">abs</span> (<span class="dt">ID</span> x) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> <span class="fu">abs</span> x</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">signum</span> (<span class="dt">ID</span> x) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> <span class="fu">signum</span> x</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fromInteger</span> x <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> <span class="fu">fromInteger</span> x</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Default</span> <span class="dt">Entity</span> <span class="kw">where</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    def <span class="ot">=</span> <span class="dt">ID</span> <span class="dv">0</span></span></code></pre></div>
<p>The <code>System</code> type is a monad transformer that will be used to implement our systems. It is a state monad that will store the current entity ID and a map of components. The <code>Entity</code> type is just a wrapper around an integer, and it is used to identify entities. <code>ECSState</code> is the type of our state inside the <code>System</code> monad. The <code>componentsList</code> map is a map from entity IDs to a list of components. The <code>Default</code> instances are used to initialize the state with default values, for better ergonomics. Now lets define our components:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Components</span> <span class="ot">=</span> <span class="dt">Components</span> {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    _position ::</span> <span class="dt">Maybe</span> <span class="dt">Position</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    _velocity ::</span> <span class="dt">Maybe</span> <span class="dt">Velocity</span>,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    _name ::</span> <span class="dt">Maybe</span> <span class="dt">Name</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    _tag ::</span> <span class="dt">Maybe</span> <span class="dt">Tag</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Default</span> <span class="dt">Components</span> <span class="kw">where</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    def <span class="ot">=</span> <span class="dt">Components</span> def def def def</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Position</span> <span class="ot">=</span> <span class="dt">Position</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Velocity</span> <span class="ot">=</span> <span class="dt">Velocity</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">Name</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tag</span> <span class="ot">=</span> <span class="dt">Ball</span> <span class="op">|</span> <span class="dt">Player</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>So our components are just records that contain the data for each component. The <code>Position</code> and <code>Velocity</code> types are just wrappers around a tuple of integers, and they are used to represent the position and velocity of an entity. The <code>Name</code> type is a wrapper around a string, and it is used to represent the name of an entity. The <code>Tag</code> type is an enumeration that is used to represent the type of an entity. If we wanted to add more Components we would just add more fields to the <code>Components</code> record. Obviously this is not extensible, but it is good enough for our purposes. <a href="https://hackage.haskell.org/package/apecs">Proper libraries</a> use Template Haskell to generate the components. Now let’s define some lenses for our components:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Components</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'ECSState</span></span></code></pre></div>
<p>makeLenses is from the lens library, and it generates lenses for each field of the record using Template Haskell. Now let’s define a function to spawn new entities:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextEntityID ::</span> <span class="dt">Entity</span> <span class="ot">-&gt;</span> <span class="dt">Entity</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>nextEntityID (<span class="dt">ID</span> x) <span class="ot">=</span> <span class="dt">ID</span> <span class="op">$</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">spawnEntity ::</span> <span class="dt">Components</span> <span class="ot">-&gt;</span> <span class="dt">System</span> <span class="dt">IO</span> <span class="dt">Entity</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>spawnEntity components <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> gets (<span class="op">^.</span>currentEntityID)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    componentsList <span class="op">%=</span> insert x components</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    currentEntityID <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x</span></code></pre></div>
<p>Look at how imperative <code>spawnEntity</code> looks! Let’s break down what this is doing. The first line gets the current entity ID from the state. <code>^.</code> is <code>view</code> as an operator, and it is used to get the value of a lens. The second line inserts the components into the map. <code>%=</code> is <code>over</code> as an operator, and it is used to map a function to the value of a lens, and then storing it into the state. The third line increments the current entity ID. <code>+= x</code> is equivalent to <code>over (+x)</code>, then storing the result into the state. While the use of lenses here doesn’t give us any additional power, it does make the code very concise and easy to read.</p>
<p>We can implement delete entity in a similar way:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">removeEntity ::</span> <span class="dt">Entity</span> <span class="ot">-&gt;</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>removeEntity entity <span class="ot">=</span> componentsList <span class="op">%=</span> delete entity</span></code></pre></div>
<p>Usually in imperative implementations, deleting entities is not a trivial task. You have to make sure that you don’t leave any dangling references in each component array. With our implementation, we don’t have to worry about any of that, since our state is immutable.</p>
<p>That’s all for our helper functions. With these functions and lenses we can write our systems.</p>
<h2 id="bouncing-balls">Bouncing Balls</h2>
<p>Let’s write a simple physics simulation of bouncing balls. We will have a movement system that will update the position of each entity based on its velocity, and a collision to detect collisions against the walls. We will also have a rendering system that will print the position of each entity. Let’s start by implementing our movement system:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">movementSystem ::</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>movementSystem <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    componentsList <span class="op">%=</span> <span class="fu">fmap</span> movement</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot">   movement ::</span> <span class="dt">Components</span> <span class="ot">-&gt;</span> <span class="dt">Components</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>            movement c<span class="op">@</span>(<span class="dt">Components</span> {_position <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Position</span> (x, y)), _velocity <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Velocity</span> (x', y'))})</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=</span> set position (clampPosition (x <span class="op">+</span> x', y <span class="op">+</span> y')) c</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>            movement c <span class="ot">=</span> c</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="ot">clamp ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>clamp min' max' x</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">&lt;</span> min' <span class="ot">=</span> min'</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">&gt;</span> max' <span class="ot">=</span> max'</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="ot">clampPosition ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Position</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>clampPosition (x, y) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Position</span> (clamp <span class="dv">0</span> (xSize <span class="op">-</span> <span class="dv">1</span>) x, clamp <span class="dv">0</span> (ySize <span class="op">-</span> <span class="dv">1</span>) y)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="ot">gridSize ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>gridSize <span class="ot">=</span> (<span class="dv">100</span>, <span class="dv">10</span>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>xSize <span class="ot">=</span> <span class="fu">fst</span> gridSize</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>ySize <span class="ot">=</span> <span class="fu">snd</span> gridSize</span></code></pre></div>
<p>This system is very simple. It just updates the position of each entity based on its velocity. The <code>movement</code> function is a helper function that does the actual movement. It takes a <code>Components</code> record, and it returns a new <code>Components</code> record with the updated position. Importantly, notice that we use normal pattern matching to select which components we want to use, if we wanted our movement system to only work for entities with the <code>Ball</code> tag, then we could simply add that to the pattern matching. The <code>clamp</code> function is a helper function that clamps a value between a minimum and a maximum. The <code>clampPosition</code> function is a helper function that clamps the position of an entity between the bounds of the screen. Now let’s implement our collision system:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">collisionSystem ::</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>collisionSystem <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    componentsList <span class="op">%=</span> <span class="fu">fmap</span> collision</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span><span class="ot">   collision ::</span> <span class="dt">Components</span> <span class="ot">-&gt;</span> <span class="dt">Components</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            collision c<span class="op">@</span>(<span class="dt">Components</span> {_position <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Position</span> (x, y)), _velocity <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Velocity</span> (x', y'))})</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> x <span class="op">&gt;=</span> xSize <span class="op">-</span> <span class="dv">1</span> <span class="ot">=</span> set velocity (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Velocity</span> (<span class="op">-</span> x', y')) c</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> x <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> set velocity (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Velocity</span> (<span class="op">-</span> x', y')) c</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> y <span class="op">&gt;=</span> ySize <span class="op">-</span> <span class="dv">1</span> <span class="ot">=</span> set velocity (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Velocity</span> (x', <span class="op">-</span> y')) c</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> y <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> set velocity (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Velocity</span> (x', <span class="op">-</span> y')) c</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> c</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            collision c <span class="ot">=</span> c</span></code></pre></div>
<p>This system is also very simple. It just checks if the entity is colliding with the walls, and if it is, it inverts the velocity. Now let’s implement our rendering system:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">renderSystem ::</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>renderSystem <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    state <span class="ot">&lt;-</span> get</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> grid <span class="ot">=</span> <span class="fu">replicate</span> ySize (<span class="fu">replicate</span> xSize <span class="ch">' '</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> grid' <span class="ot">=</span> foldl' renderBalls grid (view componentsList state)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">putStr</span> <span class="st">&quot;\ESC[2J&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">unlines</span> <span class="op">$</span> <span class="fu">reverse</span> grid'</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span><span class="ot">   renderBalls ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Components</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>                renderBalls grid c<span class="op">@</span>(<span class="dt">Components</span> {_position <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Position</span> (x, y)), _velocity <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Velocity</span> (x', y')), _tag <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">Ball</span>, _name <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Name</span> name)}) <span class="ot">=</span> set (element y <span class="op">.</span> element x) (<span class="fu">head</span> name) grid</span></code></pre></div>
<p>This system is a bit more complicated. It renders the entities as characters on a grid. The <code>renderBalls</code> function is a helper function that renders a single entity. It takes a grid and a <code>Component</code>, and it returns a new grid with the entity rendered on it. The <code>renderSystem</code> function uses <code>foldl'</code> to render all the entities, the only difference between <code>foldl</code> and <code>foldl'</code> is that the latter is strict, which usually reduces space complexity. It also uses <code>unlines</code> to convert the grid into a string, and <code>putStr</code> to print it to the console. It also uses <code>putStrLn</code> to print a newline at the end. The <code>liftIO</code> function is used to lift the IO action into the <code>System</code> monad. The <code>renderSystem</code> function also uses the ANSI escape code <code>\ESC[2J</code> to clear the console. Now let’s put it all together:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mainSystem ::</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>mainSystem <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> names <span class="ot">=</span> [<span class="ch">'a'</span><span class="op">..</span><span class="ch">'z'</span>]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    forM_ names <span class="op">$</span> \name <span class="ot">-&gt;</span> <span class="kw">do</span> spawnEntity <span class="op">$</span> <span class="dt">Components</span> (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Position</span> (<span class="fu">fromEnum</span> name <span class="ot">`mod`</span> xSize, (<span class="fu">fromEnum</span> <span class="ch">'z'</span> <span class="op">-</span> <span class="fu">fromEnum</span> name) <span class="ot">`mod`</span> ySize)) (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Velocity</span> ((<span class="fu">fromEnum</span> name <span class="ot">`mod`</span> <span class="dv">3</span>) <span class="op">+</span> <span class="dv">1</span>, (<span class="fu">fromEnum</span> name <span class="ot">`mod`</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span>)) (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">Name</span> [name]) (<span class="dt">Just</span> <span class="dt">Ball</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    repeatingSystems</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="ot">repeatingSystems ::</span> <span class="dt">System</span> <span class="dt">IO</span> ()</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>repeatingSystems <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    movementSystem</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    collisionSystem</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    renderSystem</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> threadDelay <span class="dv">100000</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    repeatingSystems</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> void <span class="op">$</span> runStateT mainSystem def</span></code></pre></div>
<p>The <code>mainSystem</code> function spawns a bunch of entities, and then it calls <code>repeatingSystems</code>. The <code>repeatingSystems</code> function calls the three systems, and then it sleeps, and then it calls itself again. The <code>main</code> function runs the <code>mainSystem</code> function with the default state. This is what you should see when you run it:</p>
<p><img src="../images/bouncingballs.gif" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how to implement an ECS in Haskell, while using lenses to make the code very concise and easy to use. I also showed how to use the ECS to implement a simple physics simulator.</p>
<p>Now let’s consider the pros and cons of lenses. The main advantage of lenses is that they make the code very concise and easy to use, the <code>lens</code> library is ridiculously huge, and almost all Haskell code you write can be rewritten using lens, but with this massive library of combinators comes complexity. There are several types of complexity that lens bring to your project. First, is the complexity of learning the library and how to properly use different categories of optics, there is <code>Getter</code>, <code>Setter</code>, <code>Traversal</code>, <code>Fold</code>, <code>Lens</code>, <code>Iso</code>, <code>Prism</code> and probably more that I don’t know about, and each of these categories has its massive library of combinators. Second, is the complexity of understanding the code, while lenses can provide very concise programs, any user that tries to read code using lens without any previous experience will find themselves very lost. The generality of lenses results in difficult to understand type signatures, often defined by other categories within lenses. Third, is the complexity of debugging the code, like I stated previously the function signatures of <code>lens</code> combinators can be very overwhelming especially to new users, and this can make debugging very difficult, and many concepts of lenses are based on category theory, which most programmers don’t know. One particularly funny example is <code>confusing</code> which uses Kan extensions and the Yoneda lemma to fuse a <code>Traversal</code>, try explaining that to a new user. Lastly, is the extra dependencies that lenses bring to your project, the <code>lens</code> library is massive, and it has many dependencies, and no one wants to wait 10 minutes for their project to compile.</p>
<p>Overall, I think lenses are a great tool, and they can be used to make your code very concise and easy to use, but they are not a silver bullet, and they should be used with caution. I think the best way to use lenses is to use them sparingly, and only use them when they make the code more concise and easier to use.</p>
<p>I hope you enjoyed this post, and I hope you learned something new. The full source code can be found on <a href="https://github.com/timeolord/ecs-lens">GitHub</a>.</p>
    </section>
</article>
        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
