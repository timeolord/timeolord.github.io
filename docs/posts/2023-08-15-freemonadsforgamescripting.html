<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Allan Wei's Blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
        </script>
        <header>
            <div class="logo">
                <img src="../images/wei-logo.svg" style="width:50%; max-width:80px; display: block; margin-left: auto; margin-right: auto;" />
                <a href="../">The Wei Zone</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blogs</a>
            </nav>
        </header>

        <main role="main">
            <h1>Free Monads for Game Scripting</h1>
            
<article>
    <section class="header">
        <p>Posted on August 15, 2023</p><br>
        
    </section>
    <section>
        <p>Let’s say you are making a game and you want to have a scripting language for your game. There are many benefits to doing so:</p>
<ol type="1">
<li>You can make your game more moddable, by loading player made scripts at runtime.</li>
<li>You can make your game designers job easier, because they don’t have to be familiar with the entire codebase to make changes, just the API for the language.</li>
<li>You can make increase your productivity by reducing compile times, because you don’t have to recompile the entire game to make changes, you can just reload the scripts at runtime.</li>
<li>You can make your game more debuggable, by allowing you to inspect the state and even change it at runtime.</li>
</ol>
<p>But implementing a whole interpreter is a lot of work! Especially if you’ve never written a compiler or interpreter before. You’ll have to deal with parsing grammars, program semantics, evaluation, and more. And if you want to make your language more powerful or performant, that means more work, which means less time spent actually making the game. But what if I told you that you can get all of these benefits with a fraction of the work? Well, you can, by using free monads.</p>
<h2 id="what-is-a-free-monad-in-category-theory">What is a Free Monad in Category Theory?</h2>
<p>A free monad is a monad that is generated by a functor in a way that is analogous to how a free group is generated by a set. A free monad can be seen as a way of representing the syntax of a computation without specifying its semantics. A free monad can also be used to combine different effects in a single monad, using the technique of monad transformers.</p>
<p>To understand what a free monad is, let us first recall what a monad is in category theory. A monad on a category <code>C</code> is an endofunctor <code>T: C -&gt; C</code>, together with two natural transformations: <code>eta: 1_C -&gt; T</code> (the unit) and <code>mu: T^2 -&gt; T</code> (the multiplication), that satisfy the monad laws. Intuitively, a monad can be thought of as adding some extra structure or context to the objects and morphisms of <code>C</code>.</p>
<p>A functor <code>F: C -&gt; D</code> is said to be forgetful if it “forgets” some of the structure or properties of the objects and morphisms in <code>C</code>. For example, the functor <code>U: Grp -&gt; Set</code> that maps a group to its underlying set and a group homomorphism to its underlying function is forgetful, because it ignores the group operations and axioms. A functor that is not forgetful is called faithful.</p>
<p>A functor <code>F: C -&gt; D</code> is said to be free if it has a left adjoint <code>G: D -&gt; C</code>, such that <span class="math display"><em>F</em> ∘ <em>G</em></span> is naturally isomorphic to the identity functor on <code>D</code>. This means that for any object <code>X</code> in <code>D</code>, there is an object <code>G(X)</code> in <code>C</code>, such that <code>F(G(X))</code> is naturally isomorphic to <code>X</code>, and for any morphism <code>f: X -&gt; Y</code> in <code>D</code>, there is a unique morphism <code>g: G(X) -&gt; G(Y)</code> in <code>C</code>, such that <code>F(g) = f</code>. Intuitively, a free functor can be thought of as adding the minimal amount of structure or properties to the objects and morphisms in <code>D</code>, such that they become objects and morphisms in <code>C</code>.</p>
<p>A free monad on a category <code>C</code> is a monad <code>T: C -&gt; C</code> that is free as an endofunctor. This means that there is a functor <code>U: C -&gt; C</code>, such that <span class="math display"><em>T</em> ∘ <em>U</em></span> is naturally isomorphic to the identity functor on <code>C</code>, and for any endofunctor <code>F: C -&gt; C</code>, there is a unique natural transformation <code>t: U</code> <span class="math display">∘</span> <code>F -&gt; F</code>, such that <code>T(t) = F</code>. Intuitively, a free monad can be thought of as adding the minimal amount of structure or context to the objects and morphisms of <code>C</code>, such that they become objects and morphisms in <code>T(C)</code>.</p>
<h2 id="a-simple-example-of-a-free-monad">A simple example of a free monad</h2>
<p>Now given a brief theoretical overview of free monads, let’s implement a simple free monad in Haskell, to understand how they work in practice. We will implement a free monad for a simple language of arithmetic expressions, and then we will interpret the expressions in the language.</p>
<p>First, we define the language of arithmetic expressions as a data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> t a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Add</span> t t (t <span class="ot">-&gt;</span> a)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Mul</span> t t (t <span class="ot">-&gt;</span> a)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>The <code>Expr</code> type is parameterized by a type <code>a</code>, which is used to represent the context of the expression. The <code>a</code> parameter is used to represent the context of the expression, for example, if we want to represent the expression <code>1 + 2 * 3</code>, we can use the <code>Expr</code> type as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> (<span class="dt">Expr</span> <span class="dt">Int</span> ())</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> <span class="dt">Mul</span> <span class="dv">2</span> <span class="dv">3</span> (\x <span class="ot">-&gt;</span> <span class="dt">Add</span> x <span class="dv">1</span> (<span class="fu">const</span> ()))</span></code></pre></div>
<p>But clearly this is very unergonomic, and annoying to use, so let’s use the free monad to fix things.
Now here’s the definition of the free monad. At least one of them, there are others with different definitions and better performance, like <a href="https://hackage.haskell.org/package/free-5.2/docs/Control-Monad-Free-Church.html">this</a>. I choose this definition since it’s the simplest one to wrap your head around (but also painfully slow):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> f a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</span></code></pre></div>
<p>The <code>Free</code> type is parameterized by a functor <code>f</code> and a type <code>a</code>. The <code>Pure</code> constructor represents a value, and the <code>Free</code> constructor represents a value that is generated by the functor <code>f</code>. One way to think about <code>Free f</code> is like a list, where <code>Pure</code> is <code>Nil</code> and <code>Free</code> is <code>Cons</code>, except here <code>Free</code> is not linear but a tree. The <code>Free</code> type is a monad and applicative with the following definitions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Pure</span> a <span class="op">&lt;*&gt;</span> <span class="dt">Pure</span> b  <span class="ot">=</span> <span class="dt">Pure</span> <span class="op">$</span> a b</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Pure</span> a <span class="op">&lt;*&gt;</span> <span class="dt">Free</span> mb <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="fu">fmap</span> a <span class="op">&lt;$&gt;</span> mb</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Free</span> ma <span class="op">&lt;*&gt;</span> b      <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">&lt;*&gt;</span> b) ma</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Pure</span> a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Free</span> m <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Free</span> (<span class="fu">fmap</span> (<span class="op">&gt;&gt;=</span> f) m)</span></code></pre></div>
<p>Now we can define a function <code>liftF</code> that lifts a functor <code>f</code> into the free monad <code>Free f</code>, <code>retract</code> that unwraps the functor <code>f</code> from the free monad <code>Free f</code>, and <code>foldFree</code> which implements the natural transformation from <code>Free f a</code> to another monad <code>m a</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftF ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>liftF <span class="ot">=</span> <span class="dt">Free</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="dt">Pure</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>retract (<span class="dt">Pure</span> a) <span class="ot">=</span> <span class="fu">return</span> a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>retract (<span class="dt">Free</span> m) <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> retract</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ot">foldFree ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> m x) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> m a</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>foldFree _ (<span class="dt">Pure</span> a)  <span class="ot">=</span> <span class="fu">return</span> a</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>foldFree f (<span class="dt">Free</span> as) <span class="ot">=</span> f as <span class="op">&gt;&gt;=</span> foldFree f</span></code></pre></div>
<p>For ease of use we should declare some helper functions that lift our constructors into the free monad:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FreeExpr</span> t <span class="ot">=</span> <span class="dt">Free</span> (<span class="dt">Expr</span> t)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">FreeExpr</span> t t</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Add</span> x y <span class="fu">id</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">FreeExpr</span> t t</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>mul x y <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Mul</span> x y <span class="fu">id</span></span></code></pre></div>
<p>Now lets write a new program using the free monad and do notation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program ::</span> <span class="dt">FreeExpr</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>program <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> add <span class="dv">12</span> <span class="dv">13</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    mul result <span class="dv">2</span></span></code></pre></div>
<p>This program by itself does not do anything, however, we can write an <code>eval</code> function which can interpret our program into <code>IO</code> monad:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">FreeExpr</span> a a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span> foldFree eval' <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    eval' (<span class="dt">Add</span> x y k) <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; + &quot;</span> <span class="op">++</span> <span class="fu">show</span> y) <span class="op">&gt;&gt;</span> <span class="fu">pure</span> (k (x <span class="op">+</span> y))</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    eval' (<span class="dt">Mul</span> x y k) <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; * &quot;</span> <span class="op">++</span> <span class="fu">show</span> y) <span class="op">&gt;&gt;</span> <span class="fu">pure</span> (k (x <span class="op">*</span> y))</span></code></pre></div>
<p>Here’s what we get when we run this program:</p>
<pre><code>&gt; eval program &gt;&gt;= print
12 + 13
25 * 2
50</code></pre>
<p>Important note is that the evaluation function can be from our free monad to any monad, not just <code>IO</code>. For example, we can write an interpreter that puts the expressions into a list instead of printing them immediately:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalToList ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">FreeExpr</span> a a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>evalToList (<span class="dt">Pure</span> a) <span class="ot">=</span> [<span class="fu">show</span> a]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>evalToList (<span class="dt">Free</span> (<span class="dt">Add</span> x y k)) <span class="ot">=</span> (<span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; + &quot;</span> <span class="op">++</span> <span class="fu">show</span> y) <span class="op">:</span> evalToList (k (x <span class="op">+</span> y))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>evalToList (<span class="dt">Free</span> (<span class="dt">Mul</span> x y k)) <span class="ot">=</span> (<span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; * &quot;</span> <span class="op">++</span> <span class="fu">show</span> y) <span class="op">:</span> evalToList (k (x <span class="op">*</span> y))</span></code></pre></div>
<p>Now we get the following result:</p>
<pre><code>&gt; evalToList program
[&quot;12 + 13&quot;,&quot;25 * 2&quot;, &quot;50&quot;]</code></pre>
<p>So hopefully that gave you a good idea of what a free monad is and how it works. Now let’s see how we can use it to implement a scripting language for our game.</p>
<h2 id="free-monads-for-game-scripting">Free monads for game scripting</h2>
    </section>
</article>
        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
