---
title: Free Monads for Game Scripting
---
Let's say you are making a game and you want to have a scripting language for your game. There are many benefits to doing so:

1. You can make your game more moddable, by loading player made scripts at runtime.
2. You can make your game designers job easier, because they don't have to be familiar with the entire codebase to make changes, just the API for the language.
3. You can make increase your productivity by reducing compile times, because you don't have to recompile the entire game to make changes, you can just reload the scripts at runtime.
4. You can make your game more debuggable, by allowing you to inspect the state and even change it at runtime.

But implementing a whole interpreter is a lot of work! Especially if you've never written a compiler or interpreter before. You'll have to deal with parsing grammars, program semantics, evaluation, and more. And if you want to make your language more powerful or performant, that means more work, which means less time spent actually making the game.  But what if I told you that you can get all of these benefits with a fraction of the work? Well, you can, by using free monads.

## What is a Free Monad in Category Theory?

A free monad is a monad that is generated by a functor in a way that is analogous to how a free group is generated by a set. A free monad can be seen as a way of representing the syntax of a computation without specifying its semantics. A free monad can also be used to combine different effects in a single monad, using the technique of monad transformers.

To understand what a free monad is, let us first recall what a monad is in category theory. A monad on a category `C` is an endofunctor `T: C -> C`, together with two natural transformations: `eta: 1_C -> T` (the unit) and `mu: T^2 -> T` (the multiplication), that satisfy the monad laws. Intuitively, a monad can be thought of as adding some extra structure or context to the objects and morphisms of `C`.

A functor `F: C -> D` is said to be forgetful if it "forgets" some of the structure or properties of the objects and morphisms in `C`. For example, the functor `U: Grp -> Set` that maps a group to its underlying set and a group homomorphism to its underlying function is forgetful, because it ignores the group operations and axioms. A functor that is not forgetful is called faithful.

A functor `F: C -> D` is said to be free if it has a left adjoint `G: D -> C`, such that $$ F \circ G $$ is naturally isomorphic to the identity functor on `D`. This means that for any object `X` in `D`, there is an object `G(X)` in `C`, such that `F(G(X))` is naturally isomorphic to `X`, and for any morphism `f: X -> Y` in `D`, there is a unique morphism `g: G(X) -> G(Y)` in `C`, such that `F(g) = f`. Intuitively, a free functor can be thought of as adding the minimal amount of structure or properties to the objects and morphisms in `D`, such that they become objects and morphisms in `C`.

A free monad on a category `C` is a monad `T: C -> C` that is free as an endofunctor. This means that there is a functor `U: C -> C`, such that $$ T \circ U $$ is naturally isomorphic to the identity functor on `C`, and for any endofunctor `F: C -> C`, there is a unique natural transformation `t: U` $$ \circ $$ `F -> F`, such that `T(t) = F`. Intuitively, a free monad can be thought of as adding the minimal amount of structure or context to the objects and morphisms of `C`, such that they become objects and morphisms in `T(C)`.

## A simple example of a free monad

Now given a brief theoretical overview of free monads, let's implement a simple free monad in Haskell, to understand how they work in practice. We will implement a free monad for a simple language of arithmetic expressions, and then we will interpret the expressions in the language. 

First, we define the language of arithmetic expressions as a data type:

```haskell
data Expr t a
  = Add t t (t -> a)
  | Mul t t (t -> a)
  deriving Functor
```

The `Expr` type is parameterized by a type `a`, which is used to represent the context of the expression. The `a` parameter is used to represent the context of the expression, for example, if we want to represent the expression `1 + 2 * 3`, we can use the `Expr` type as follows:

```haskell
expr :: Expr Int (Expr Int ())
expr = Mul 2 3 (\x -> Add x 1 (const ()))
```

But clearly this is very unergonomic, and annoying to use, so let's use the free monad to fix things.
Now here's the definition of the free monad. At least one of them, there are others with different definitions and better performance, like [this](https://hackage.haskell.org/package/free-5.2/docs/Control-Monad-Free-Church.html). I choose this definition since it's the simplest one to wrap your head around (but also painfully slow):

```haskell
data Free f a
  = Pure a
  | Free (f (Free f a))
```

The `Free` type is parameterized by a functor `f` and a type `a`. The `Pure` constructor represents a value, and the `Free` constructor represents a value that is generated by the functor `f`. One way to think about `Free f` is like a list, where `Pure` is `Nil` and `Free` is `Cons`, except here `Free` is not linear but a tree. The `Free` type is a monad and applicative with the following definitions:

```haskell
instance Functor f => Applicative (Free f) where
    pure = Pure
    Pure a <*> Pure b  = Pure $ a b
    Pure a <*> Free mb = Free $ fmap a <$> mb
    Free ma <*> b      = Free $ fmap (<*> b) ma

instance Functor f => Monad (Free f) where
    Pure a >>= f = f a
    Free m >>= f = Free (fmap (>>= f) m)
```

Now we can define a function `liftF` that lifts a functor `f` into the free monad `Free f`, `retract` that unwraps the functor `f` from the free monad `Free f`, and `foldFree` which implements the natural transformation from `Free f a` to another monad `m a`:

```haskell
liftF :: Functor f => f a -> Free f a
liftF = Free . fmap Pure

retract :: Monad f => Free f a -> f a
retract (Pure a) = return a
retract (Free m) = m >>= retract

foldFree :: Monad m => (forall x. f x -> m x) -> Free f a -> m a
foldFree _ (Pure a)  = return a
foldFree f (Free as) = f as >>= foldFree f
```

For ease of use we should declare some helper functions that lift our constructors into the free monad:

```haskell
type FreeExpr t = Free (Expr t)

add :: t -> t -> FreeExpr t t
add x y = liftF $ Add x y id

mul :: t -> t -> FreeExpr t t
mul x y = liftF $ Mul x y id
```

Now lets write a new program using the free monad and do notation:

```haskell
program :: FreeExpr Int Int
program = do
    result <- add 12 13
    mul result 2
```

This program by itself does not do anything, however, we can write an `eval` function which can interpret our program into `IO` monad:

```haskell
eval :: (Num a, Show a) => FreeExpr a a -> IO a
eval = foldFree eval' where
    eval' (Add x y k) = putStrLn (show x ++ " + " ++ show y) >> pure (k (x + y))
    eval' (Mul x y k) = putStrLn (show x ++ " * " ++ show y) >> pure (k (x * y))
```

Here's what we get when we run this program:

```
> eval program >>= print
12 + 13
25 * 2
50
```

Important note is that the evaluation function can be from our free monad to any monad, not just `IO`. For example, we can write an interpreter that puts the expressions into a list instead of printing them immediately:

```haskell
evalToList :: (Num a, Show a) => FreeExpr a a -> [String]
evalToList (Pure a) = [show a]
evalToList (Free (Add x y k)) = (show x ++ " + " ++ show y) : evalToList (k (x + y))
evalToList (Free (Mul x y k)) = (show x ++ " * " ++ show y) : evalToList (k (x * y))
```

Now we get the following result:

```
> evalToList program
["12 + 13","25 * 2", "50"]
```

So hopefully that gave you a good idea of what a free monad is and how it works. Now let's see how we can use it to implement a scripting language for our game.

## Free monads for game scripting