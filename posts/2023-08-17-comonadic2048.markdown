---
title: 2048 Using Comoands (The Ascended Way?)
---
2048 is a popular single-player puzzle game where the goal is to merge tiles with the same power of 2 until you reach 2048. Since the game is conceptually quite simple it will be a good example to demonstrate some lesser used techniques based on category theory. There are several existing implementations of 2048 in Haskell (such as [this](https://github.com/gregorulm/h2048) and [this](https://github.com/Javran/h2048)), however, they use a more direct method of repersenting the board state. In this article I will use Comoands to repersent the board state, and go through the category theory background and the step-by-step implementation, and why we would want to use a Comoand in the first place.

# What is a Comoand anyways?
Comoands are a concept from category theory that can be used to model contextual computations in functional programming. Comonads are the dual of Monads, the dual just means to switch the arrows. While Monads are about adding extra context or effects to a computation, Comoands are about extracting values or information from a context.The core essence of a Comoand is that it is a container that holds values and provides a way to access them. 

Let's construct a Comoand by reversing the arrows of the Monad! Here we can see our Monad class that we're familiar with:
```haskell
class Functor m => Monad m where
  return :: a -> m a
  join :: m (m a) -> m a
  bind :: (a -> m b) -> m a -> m b
```
Here's what happens when we reverse them:
```haskell
class Functor w => Comoand w where
  coreturn :: w a -> a
  cojoin :: w a -> w (w a)
  cobind :: (w a -> b) -> w a -> w b
```
I've named prefixed co- to each function so that you can clearly see the connection however, more often they are named like this:
```haskell
class Functor w => Comoand w where
  extract :: w a -> a
  duplicate :: w a -> w (w a)
  extend :: (w a -> b) -> w a -> w b
```
Notice that the functor requirement for the Monad also applies to the Comoand as well. Already this allows us to use our good friend `fmap`. Many common programming constructs, such as streams and zippers, can be considered as a Comoand, but for our implementation I will use this data type:
```haskell
data Store s a = Store (s -> a) s
```
This is known as the Store Comoand. Let's break down this data type and implement the Comoand instance for it.